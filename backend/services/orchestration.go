package services

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"sync"
	"sync/atomic"
	"time"

	"bike-map/entities"
	"bike-map/interfaces"
	"bike-map/utils"

	"github.com/pocketbase/pocketbase/core"
)

// TileRequest represents a priority tile generation request
type TileRequest struct {
	Coords   entities.TileCoordinates
	Response chan []byte
}

// OrchestrationService handles synchronization between PocketBase, MVTGenerator, and MVTCache
// It acts as the controller coordinating MVTGenerator, MVTCache, and EngagementService
type OrchestrationService struct {
	mvtGenerator      interfaces.MVTGenerator
	cache             interfaces.MVTCache
	backup            interfaces.MVTBackup
	engagementService interfaces.Engagement

	// Tile generation queues
	priorityQueue   chan TileRequest
	backgroundQueue chan entities.TileCoordinates
	stopChan        chan struct{}
	wg              sync.WaitGroup
}

// NewOrchestrationService creates a new OrchestrationService
func NewOrchestrationService(
	mvtGenerator interfaces.MVTGenerator,
	engagementService interfaces.Engagement,
	cache interfaces.MVTCache,
) *OrchestrationService {
	o := &OrchestrationService{
		mvtGenerator:      mvtGenerator,
		cache:             cache,
		engagementService: engagementService,		
		priorityQueue:     make(chan TileRequest, 100000),
		backgroundQueue:   make(chan entities.TileCoordinates, 1000000),
		stopChan:          make(chan struct{}),
	}

	o.wg.Add(1)
	go o.tileWorker()

	return o
}

// tileWorker processes tile generation requests, prioritizing handler requests
func (o *OrchestrationService) tileWorker() {
	defer o.wg.Done()
	log.Println("Tile worker started")

	for {
		// Priority queue takes precedence
		select {
		case req := <-o.priorityQueue:
			o.processPriorityRequest(req)
			continue
		case <-o.stopChan:
			log.Println("Tile worker stopping")
			return
		default:
		}

		// If no priority requests, process background or wait
		select {
		case req := <-o.priorityQueue:
			o.processPriorityRequest(req)
		case coords := <-o.backgroundQueue:
			o.processBackgroundTile(coords)
		case <-o.stopChan:
			log.Println("Tile worker stopping")
			return
		}
	}
}

// processPriorityRequest handles a priority tile generation request
func (o *OrchestrationService) processPriorityRequest(req TileRequest) {
	data, err := o.mvtGenerator.GetTile(context.Background(), req.Coords)
	if err != nil {
		log.Printf("Failed to generate priority tile %d/%d/%d: %v", req.Coords.Z, req.Coords.X, req.Coords.Y, err)
		data = nil
	}

	// Store in cache
	if err := o.cache.StoreTile(req.Coords, data); err != nil {
		log.Printf("Failed to store priority tile: %v", err)
	}

	// Send response
	req.Response <- data
}

// processBackgroundTile handles a background tile generation request
func (o *OrchestrationService) processBackgroundTile(coords entities.TileCoordinates) {
	// Check if tile is already valid (might have been generated by priority request)
	_, status, _ := o.cache.GetTileWithStatus(coords)
	if status == interfaces.TileValid {
		return
	}

	data, err := o.mvtGenerator.GetTile(context.Background(), coords)
	if err != nil {
		log.Printf("Failed to generate background tile %d/%d/%d: %v", coords.Z, coords.X, coords.Y, err)
		return
	}

	// Store in cache
	if err := o.cache.StoreTile(coords, data); err != nil {
		log.Printf("Failed to store background tile: %v", err)
	}
}

// RequestTile requests priority generation of a tile, blocking until complete or timeout
func (o *OrchestrationService) RequestTile(coords entities.TileCoordinates) ([]byte, error) {
	respChan := make(chan []byte, 1)
	req := TileRequest{Coords: coords, Response: respChan}

	// Try to queue the request
	select {
	case o.priorityQueue <- req:
		// Request queued
	case <-time.After(5 * time.Second):
		return nil, errors.New("timeout queuing tile request")
	}

	// Wait for response
	select {
	case data := <-respChan:
		return data, nil
	case <-time.After(5 * time.Second):
		return nil, errors.New("timeout waiting for tile generation")
	}
}

// Stop gracefully shuts down the tile worker
func (o *OrchestrationService) Stop() {
	close(o.stopChan)
	o.wg.Wait()
	log.Println("Tile worker stopped")
}

// HandleTrailCreated handles trail creation: sync to generator and queue tile generation
func (s *OrchestrationService) HandleTrailCreated(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Handling trail creation: %s", trailID)

	if err := s.syncTrailFromPBToGenerator(ctx, app, trailID); err != nil {
		return fmt.Errorf("failed to sync trail to generator: %w", err)
	}

	// Get tiles for the new trail
	tiles, err := s.mvtGenerator.GetTrailTiles(ctx, trailID)
	if err != nil {
		log.Printf("Failed to get trail tiles: %v", err)
		return nil
	}

	// Invalidate tiles in all storages and queue for background generation
	s.invalidateAndQueueTiles(tiles)

	log.Printf("Successfully handled trail creation: %s (queued %d tiles)", trailID, len(tiles))
	return nil
}

// HandleTrailUpdated handles trail update: get old tiles, update generator, get new tiles, queue generation
func (s *OrchestrationService) HandleTrailUpdated(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Handling trail update: %s", trailID)

	// Get tiles for old trail position
	oldTiles, err := s.mvtGenerator.GetTrailTiles(ctx, trailID)
	if err != nil {
		log.Printf("Could not get old tiles for trail %s: %v", trailID, err)
		oldTiles = nil
	}

	// Update trail in generator
	if err := s.syncTrailFromPBToGenerator(ctx, app, trailID); err != nil {
		return fmt.Errorf("failed to sync trail to generator: %w", err)
	}

	// Get tiles for new trail position
	newTiles, err := s.mvtGenerator.GetTrailTiles(ctx, trailID)
	if err != nil {
		log.Printf("Could not get new tiles for trail %s: %v", trailID, err)
		newTiles = nil
	}

	// Aggregate tiles and queue for background generation
	allTiles := mergeTiles(oldTiles, newTiles)
	s.invalidateAndQueueTiles(allTiles)

	log.Printf("Successfully handled trail update: %s (queued %d tiles)", trailID, len(allTiles))
	return nil
}

// HandleTrailDeleted handles trail deletion: get tiles, delete from generator, queue tile regeneration
func (s *OrchestrationService) HandleTrailDeleted(ctx context.Context, trailID string) error {
	log.Printf("Handling trail deletion: %s", trailID)

	// Get tiles for the trail before deletion
	tiles, err := s.mvtGenerator.GetTrailTiles(ctx, trailID)
	if err != nil {
		log.Printf("Could not get tiles for trail %s before deletion: %v", trailID, err)
		tiles = nil
	}

	// Delete from generator
	if err := s.mvtGenerator.DeleteTrail(ctx, trailID); err != nil {
		return fmt.Errorf("failed to delete trail from generator: %w", err)
	}

	// Invalidate and queue affected tiles for regeneration
	s.invalidateAndQueueTiles(tiles)

	log.Printf("Successfully handled trail deletion: %s (queued %d tiles)", trailID, len(tiles))
	return nil
}

// HandleRatingCreated handles rating creation: update PocketBase average, sync to generator, regenerate tiles
func (s *OrchestrationService) HandleRatingCreated(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Handling rating creation for trail: %s", trailID)

	if s.engagementService != nil {
		if err := s.engagementService.UpdateRatingAverage(app, trailID); err != nil {
			log.Printf("Failed to update rating average: %v", err)
		}
	}

	return s.updateTrailAndRegenerateTiles(ctx, app, trailID)
}

// HandleRatingUpdated handles rating update: update PocketBase average, sync to generator, regenerate tiles
func (s *OrchestrationService) HandleRatingUpdated(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Handling rating update for trail: %s", trailID)

	if s.engagementService != nil {
		if err := s.engagementService.UpdateRatingAverage(app, trailID); err != nil {
			log.Printf("Failed to update rating average: %v", err)
		}
	}

	return s.updateTrailAndRegenerateTiles(ctx, app, trailID)
}

// HandleRatingDeleted handles rating deletion: update PocketBase average, sync to generator, regenerate tiles
func (s *OrchestrationService) HandleRatingDeleted(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Handling rating deletion for trail: %s", trailID)

	if s.engagementService != nil {
		if err := s.engagementService.DeleteRatingAverage(app, trailID); err != nil {
			log.Printf("Failed to delete rating average: %v", err)
		}
	}

	return s.updateTrailAndRegenerateTiles(ctx, app, trailID)
}

// HandleCommentCreated handles comment creation: sync to generator, regenerate tiles
func (s *OrchestrationService) HandleCommentCreated(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Handling comment creation for trail: %s", trailID)
	return s.updateTrailAndRegenerateTiles(ctx, app, trailID)
}

// HandleCommentDeleted handles comment deletion: sync to generator, regenerate tiles
func (s *OrchestrationService) HandleCommentDeleted(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Handling comment deletion for trail: %s", trailID)
	return s.updateTrailAndRegenerateTiles(ctx, app, trailID)
}

// updateTrailAndRegenerateTiles syncs trail to generator and queues tile regeneration
func (s *OrchestrationService) updateTrailAndRegenerateTiles(ctx context.Context, app core.App, trailID string) error {
	if err := s.syncTrailFromPBToGenerator(ctx, app, trailID); err != nil {
		return err
	}

	// Get tiles for the trail and queue for regeneration
	tiles, err := s.mvtGenerator.GetTrailTiles(ctx, trailID)
	if err != nil {
		log.Printf("Could not get tiles for trail %s: %v", trailID, err)
		return nil
	}

	s.invalidateAndQueueTiles(tiles)
	return nil
}

// invalidateAndQueueTiles invalidates tiles in cache and queues them for background generation
func (s *OrchestrationService) invalidateAndQueueTiles(tiles []entities.TileCoordinates) {
	if len(tiles) == 0 {
		return
	}

	// Invalidate in cache
	if err := s.cache.InvalidateTiles(tiles); err != nil {
		log.Printf("Failed to invalidate tiles: %v", err)
	}

	// Queue for background generation
	for _, tile := range tiles {
		select {
		case s.backgroundQueue <- tile:
		default:
			// Queue full, skip (will be generated on demand)
		}
	}
}

// mergeTiles merges two tile slices, removing duplicates
func mergeTiles(a, b []entities.TileCoordinates) []entities.TileCoordinates {
	seen := make(map[string]bool)
	var result []entities.TileCoordinates

	for _, tile := range a {
		key := fmt.Sprintf("%d-%d-%d", tile.Z, tile.X, tile.Y)
		if !seen[key] {
			seen[key] = true
			result = append(result, tile)
		}
	}

	for _, tile := range b {
		key := fmt.Sprintf("%d-%d-%d", tile.Z, tile.X, tile.Y)
		if !seen[key] {
			seen[key] = true
			result = append(result, tile)
		}
	}

	return result
}

// syncTrailFromPBToGenerator synchronizes a trail with full GPX processing
func (s *OrchestrationService) syncTrailFromPBToGenerator(ctx context.Context, app core.App, trailID string) error {
	log.Printf("Syncing trail %s to generator", trailID)

	// 1. Get trail record from PocketBase
	trail, err := app.FindRecordById("trails", trailID)
	if err != nil {
		return fmt.Errorf("failed to find trail %s: %w", trailID, err)
	}

	// 2. Get GPX file name
	gpxFile := trail.GetString("file")
	if gpxFile == "" {
		return fmt.Errorf("trail %s has no GPX file", trailID)
	}

	// 3. Read GPX file from PocketBase filesystem
	gpxData, err := readGPXFromPocketBase(app, trail, gpxFile)
	if err != nil {
		return fmt.Errorf("failed to read GPX: %w", err)
	}

	// 4. Parse GPX data
	parsedGPX, err := utils.ParseGPXFile(gpxData)
	if err != nil {
		return fmt.Errorf("failed to parse GPX: %w", err)
	}

	// 5. Get engagement data
	ratingAvg, ratingCount, commentCount := s.getTrailEngagementDataFromPB(app, trailID)

	// 6. Serialize elevation data
	elevationJSON, err := json.Marshal(parsedGPX.ElevationData)
	if err != nil {
		return fmt.Errorf("failed to marshal elevation data: %w", err)
	}

	// 7. Prepare tags JSON
	tagsJSON := trail.GetString("tags")
	if tagsJSON == "" {
		tagsJSON = "[]"
	}

	// 8. Create trail data and update generator
	trailData := entities.Trail{
		ID:            trail.Id,
		Name:          trail.GetString("name"),
		Description:   trail.GetString("description"),
		Level:         trail.GetString("level"),
		Tags:          tagsJSON,
		OwnerID:       trail.GetString("owner"),
		GPXFile:       gpxFile,
		LineStringWKT: parsedGPX.LineStringWKT,
		ElevationJSON: string(elevationJSON),
		CreatedAt:     trail.GetDateTime("created").Time(),
		UpdatedAt:     trail.GetDateTime("updated").Time(),
		RatingAvg:     ratingAvg,
		RatingCount:   ratingCount,
		CommentCount:  commentCount,
		Ridden:        trail.GetBool("ridden"),
	}

	if err := s.mvtGenerator.UpdateTrail(ctx, trailData); err != nil {
		return fmt.Errorf("failed to update trail in generator: %w", err)
	}

	log.Printf("Successfully synced trail %s to generator", trailID)
	return nil
}

// SyncAllTrails synchronizes all trails from PocketBase to generator and generates all tiles
func (s *OrchestrationService) SyncAllTrails(ctx context.Context, app core.App) error {
	log.Println("Starting full trail synchronization")

	// Clear all existing trails from generator first
	if err := s.mvtGenerator.ClearAllTrails(ctx); err != nil {
		return fmt.Errorf("failed to clear existing trails: %w", err)
	}

	// Clear all tiles from cache
	if err := s.cache.ClearAllTiles(); err != nil {
		log.Printf("Failed to clear cache: %v", err)
	}

	// Get all trails from PocketBase
	trails, err := app.FindAllRecords("trails")
	if err != nil {
		return fmt.Errorf("failed to get trails from PocketBase: %w", err)
	}

	totalTrails := len(trails)
	log.Printf("Syncing %d trails from PocketBase to generator using 10 workers\n", totalTrails)

	// Collect all unique tiles from all trails (protected by mutex)
	var tilesMu sync.Mutex
	allTiles := make(map[string]entities.TileCoordinates)

	// Progress tracking
	var completed int32

	// Worker pool
	const numWorkers = 20
	trailChan := make(chan *core.Record, totalTrails)
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for trail := range trailChan {
				if err := s.syncTrailFromPBToGenerator(ctx, app, trail.Id); err != nil {
					log.Printf("Failed to import trail %s (%s): %v\n", trail.Id, trail.GetString("name"), err)
					atomic.AddInt32(&completed, 1)
					continue
				}

				// Get tiles for this trail
				tiles, err := s.mvtGenerator.GetTrailTiles(ctx, trail.Id)
				if err != nil {
					log.Printf("Failed to get tiles for trail %s: %v", trail.Id, err)
					atomic.AddInt32(&completed, 1)
					continue
				}

				// Add to unique tiles set
				tilesMu.Lock()
				for _, tile := range tiles {
					key := fmt.Sprintf("%d-%d-%d", tile.Z, tile.X, tile.Y)
					allTiles[key] = tile
				}
				tilesMu.Unlock()

				done := atomic.AddInt32(&completed, 1)
				log.Printf("Imported trail %d/%d: %s\n", done, totalTrails, trail.GetString("name"))
			}
		}()
	}

	// Send trails to workers
	for _, trail := range trails {
		trailChan <- trail
	}
	close(trailChan)

	// Wait for all workers to complete
	wg.Wait()

	// Convert map to slice
	var uniqueTiles []entities.TileCoordinates
	for _, tile := range allTiles {
		uniqueTiles = append(uniqueTiles, tile)
	}

	// Queue all tiles for background generation
	log.Printf("Queueing %d unique tiles for background generation", len(uniqueTiles))
	s.invalidateAndQueueTiles(uniqueTiles)

	log.Println("Completed trail synchronization, tiles queued for background generation")
	return nil
}

// getTrailEngagementDataFromPB retrieves rating and comment engagement data for a trail from PocketBase
func (s *OrchestrationService) getTrailEngagementDataFromPB(app core.App, trailId string) (float64, int, int) {
	var ratingAvg float64 = 0.0
	var ratingCount int = 0
	var commentCount int = 0

	// Get rating average and count from rating_average collection
	ratingAverageCollection, err := app.FindCollectionByNameOrId("rating_average")
	if err == nil {
		averageRecords, err := app.FindRecordsByFilter(ratingAverageCollection, fmt.Sprintf("trail = '%s'", trailId), "", 1, 0)
		if err == nil && len(averageRecords) > 0 {
			record := averageRecords[0]
			ratingAvg = record.GetFloat("average")
			ratingCount = int(record.GetFloat("count"))
		}
	}

	// Get comment count from trail_comments collection
	commentsCollection, err := app.FindCollectionByNameOrId("trail_comments")
	if err == nil {
		commentRecords, err := app.FindRecordsByFilter(commentsCollection, fmt.Sprintf("trail = '%s'", trailId), "", 0, 0)
		if err == nil {
			commentCount = len(commentRecords)
		}
	}

	return ratingAvg, ratingCount, commentCount
}

// readGPXFromPocketBase reads a GPX file directly from PocketBase storage filesystem
func readGPXFromPocketBase(app core.App, trail *core.Record, filename string) ([]byte, error) {
	fileKey := trail.BaseFilesPath() + "/" + filename

	fsys, err := app.NewFilesystem()
	if err != nil {
		return nil, fmt.Errorf("failed to initialize filesystem: %w", err)
	}
	defer fsys.Close()

	reader, err := fsys.GetReader(fileKey)
	if err != nil {
		return nil, fmt.Errorf("failed to get GPX file: %w", err)
	}
	defer reader.Close()

	return io.ReadAll(reader)
}

// Compile-time check to ensure OrchestrationService implements interfaces.SyncService
var _ interfaces.SyncTrails = (*OrchestrationService)(nil)
var _ interfaces.TileRequester = (*OrchestrationService)(nil)
